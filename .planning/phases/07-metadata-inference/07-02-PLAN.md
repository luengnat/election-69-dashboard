---
phase: 07-metadata-inference
plan: 02
type: execute
wave: 2
depends_on:
  - 07-01
files_modified:
  - batch_processor.py
autonomous: true

must_haves:
  truths:
    - "Batch processor pre-fills BallotData with path metadata before OCR"
    - "System falls back to OCR extraction when path parsing returns nothing"
    - "OCR results are authoritative - path data only fills gaps"
    - "Metadata source is tracked in confidence_details for auditing"
  artifacts:
    - path: "batch_processor.py"
      provides: "Metadata pre-fill integration in process_single()"
      contains: "metadata_parser"
    - path: "batch_processor.py"
      provides: "OCR fallback with gap-filling logic"
      contains: "path_metadata"
  key_links:
    - from: "batch_processor.py"
      to: "metadata_parser.py"
      via: "from metadata_parser import PathMetadataParser"
      pattern: "PathMetadataParser\\(\\)"
    - from: "batch_processor.process_single"
      to: "ballot_ocr.extract_ballot_data_with_ai"
      via: "pre-fill before OCR, merge after OCR"
      pattern: "path_metadata\\.province"
---

<objective>
Integrate PathMetadataParser with BatchProcessor to pre-fill metadata from file paths before OCR extraction.

Purpose: Reduce OCR burden by using path-derived metadata, with OCR as authoritative fallback
Output: Modified batch_processor.py with metadata pre-fill and OCR fallback logic
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-metadata-inference/07-RESEARCH.md
@.planning/phases/07-metadata-inference/07-01-PLAN.md

# Core files to modify
@batch_processor.py
@ballot_ocr.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PathMetadataParser to BatchProcessor</name>
  <files>batch_processor.py</files>
  <action>
Modify batch_processor.py to import and initialize PathMetadataParser:

1. Add import at top of file (after existing imports):
   ```python
   from metadata_parser import PathMetadataParser
   ```

2. In BatchProcessor.__init__(), add:
   ```python
   self.metadata_parser = PathMetadataParser()
   ```
   (Initialize after rate_limiter, before enable_memory_cleanup)

This gives BatchProcessor access to path-based metadata extraction.
Do NOT modify process_single() yet - that's the next task.
  </action>
  <verify>python3 -c "from batch_processor import BatchProcessor; b = BatchProcessor(); print(hasattr(b, 'metadata_parser'))" | grep "True"</verify>
  <done>BatchProcessor has metadata_parser attribute initialized with PathMetadataParser instance</done>
</task>

<task type="auto">
  <name>Task 2: Add metadata pre-fill and OCR fallback logic</name>
  <files>batch_processor.py</files>
  <action>
Modify process_single() method to integrate path metadata with OCR:

1. At the start of process_single(), before rate_limiter, add:
   ```python
   # Pre-extract metadata from file path (Phase 7)
   path_metadata = self.metadata_parser.parse_path(image_path)
   ```

2. After the API call returns ballot_data (inside the with block), add merge logic:
   ```python
   if ballot_data:
       # Pre-fill from path if OCR missed these fields (path is NOT authoritative)
       if not ballot_data.province and path_metadata.province:
           ballot_data.province = path_metadata.province
       if not ballot_data.constituency_number and path_metadata.constituency_number:
           ballot_data.constituency_number = path_metadata.constituency_number
       if not ballot_data.district and path_metadata.district:
           ballot_data.district = path_metadata.district
       if not ballot_data.polling_unit and path_metadata.polling_unit:
           ballot_data.polling_unit = path_metadata.polling_unit
   ```

Key principle: OCR is authoritative. Path metadata only fills GAPS where OCR returned empty.
Do NOT overwrite OCR values with path values.
  </action>
  <verify>python3 -c "
from batch_processor import BatchProcessor
from unittest.mock import patch, MagicMock

# Check that process_single uses metadata_parser
b = BatchProcessor()
src = open('batch_processor.py').read()
assert 'path_metadata' in src, 'path_metadata not found'
assert 'metadata_parser.parse_path' in src, 'metadata_parser.parse_path not found'
print('OK: metadata pre-fill logic present')
"</verify>
  <done>process_single() extracts path metadata before OCR and pre-fills BallotData only for empty fields</done>
</task>

<task type="auto">
  <name>Task 3: Add metadata source tracking to confidence_details</name>
  <files>batch_processor.py</files>
  <action>
Add metadata source tracking for auditing in the process_single() merge logic:

After the pre-fill logic (inside the `if ballot_data:` block), add:
```python
# Track metadata source for auditing (Phase 7)
ballot_data.confidence_details["metadata_source"] = {
    "province": "path" if path_metadata.province and not ballot_data.province else "ocr",
    "constituency": "path" if path_metadata.constituency_number and not ballot_data.constituency_number else "ocr",
    "path_confidence": path_metadata.confidence,
}

# Log any mismatches between path and OCR for debugging
if (path_metadata.province and ballot_data.province and
    path_metadata.province != ballot_data.province):
    ballot_data.confidence_details["province_mismatch"] = {
        "path": path_metadata.province,
        "ocr": ballot_data.province
    }
```

This provides audit trail showing whether each field came from path or OCR, and flags any mismatches.
  </action>
  <verify>python3 -c "
src = open('batch_processor.py').read()
assert 'metadata_source' in src, 'metadata_source not found in confidence_details'
assert 'province_mismatch' in src, 'province_mismatch logging not found'
print('OK: metadata source tracking present')
"</verify>
  <done>confidence_details contains metadata_source dict tracking origin of each field (path vs OCR)</done>
</task>

</tasks>

<verification>
1. BatchProcessor imports PathMetadataParser from metadata_parser
2. BatchProcessor.__init__ creates self.metadata_parser instance
3. process_single() calls metadata_parser.parse_path() before OCR
4. process_single() pre-fills BallotData fields only when OCR returned empty
5. confidence_details["metadata_source"] tracks field origins
6. Province mismatches are logged in confidence_details["province_mismatch"]
</verification>

<success_criteria>
- BatchProcessor integrates PathMetadataParser for path-based metadata extraction
- Metadata is pre-filled before OCR to reduce extraction burden
- OCR results remain authoritative - path data only fills gaps
- Metadata source is tracked in confidence_details for auditing
- Province mismatches between path and OCR are logged for review
</success_criteria>

<output>
After completion, create `.planning/phases/07-metadata-inference/07-02-SUMMARY.md`
</output>
