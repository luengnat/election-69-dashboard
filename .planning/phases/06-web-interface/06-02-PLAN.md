---
phase: 06-web-interface
plan: "02"
type: execute
wave: 2
depends_on:
  - "06-01"
files_modified:
  - web_ui.py
autonomous: true
user_setup: []
must_haves:
  truths:
    - "User can view extracted vote counts in a structured table"
    - "User can download constituency PDF reports from web UI"
    - "User can download batch summary PDF from web UI"
  artifacts:
    - path: "web_ui.py"
      provides: "Results display and PDF download functionality"
      min_lines: 150
      exports: ["demo", "process_ballots"]
  key_links:
    - from: "web_ui.py"
      to: "ballot_ocr.py"
      via: "from ballot_ocr import generate_constituency_pdf, generate_batch_pdf"
      pattern: "generate_constituency_pdf|generate_batch_pdf"
---

<objective>
Add results display with structured vote count tables and PDF download buttons for constituency reports and batch summaries.

Purpose: Enable users to view extracted data in a clear table format and download PDF reports directly from the web UI.
Output: Enhanced web_ui.py with vote count table display and PDF download functionality
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@batch_processor.py
@ballot_ocr.py

## PDF Generation Functions (from ballot_ocr.py)

The existing codebase has these PDF functions:

1. **generate_constituency_pdf(agg: AggregatedResults, output_path: str) -> bool**
   - Creates constituency-level PDF report
   - agg comes from aggregate_ballot_results()

2. **generate_batch_pdf(aggregated_results: dict, ballot_data_list: list, output_path: str) -> bool**
   - Creates batch summary PDF with charts
   - Shows all constituencies in batch

3. **aggregate_ballot_results(ballot_data_list: list) -> dict**
   - Aggregates multiple ballots by province/constituency
   - Returns dict with AggregatedResults objects

## Data Flow

```
files -> BatchProcessor -> BatchResult.results (list[BallotData])
                            -> aggregate_ballot_results()
                            -> generate_constituency_pdf() (per constituency)
                            -> generate_batch_pdf() (overall)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add vote count table display</name>
  <files>web_ui.py</files>
  <action>
Enhance the results display in web_ui.py to show detailed vote counts in a structured table.

1. **Update format_results function** to include vote counts:
   - Add columns for candidate votes: "Candidate 1", "Candidate 2", etc. (up to 6)
   - For party-list forms, show "Party 1", "Party 2", etc.
   - Handle different form types appropriately

2. **Create format_vote_table function**:
   - Takes a BallotData object
   - Returns formatted vote count string for display
   - Format: "Candidate Name: 123" per line, or "Party Name: 456"

3. **Add expandable results section**:
   - Use gr.Accordion or gr.Row for expandable detailed view
   - Main table shows summary (Image, Province, Constituency, Confidence)
   - Expanded view shows full vote breakdown

4. **Add summary statistics**:
   - Total ballots processed
   - Success rate (processed/total)
   - Processing time
   - Number of errors

Update the Dataframe definition:
```python
results_table = gr.Dataframe(
    headers=[
        "Image", "Province", "Constituency", "Station",
        "Form Type", "Confidence", "Votes"
    ],
    label="Extracted Results",
    wrap=True  # Enable text wrapping for vote columns
)
```

The Votes column will contain a summary like "6 candidates, 1,234 total votes" with full details in an expandable section.
</action>
  <verify>python -c "from web_ui import format_results, format_vote_table; print('Vote table functions OK')" && echo "Functions work"</verify>
  <done>Results table shows Image, Province, Constituency, Station, Form Type, Confidence, and vote summary in structured columns</done>
</task>

<task type="auto">
  <name>Task 2: Add PDF download functionality</name>
  <files>web_ui.py</files>
  <action>
Add PDF download buttons to the Gradio interface that generate and provide constituency and batch PDF reports.

1. **Add imports**:
```python
from ballot_ocr import (
    BallotData,
    aggregate_ballot_results,
    generate_constituency_pdf,
    generate_batch_pdf,
    AggregatedResults
)
import tempfile
import os
from pathlib import Path
```

2. **Create generate_pdfs function**:
   - Takes the list of BallotData results
   - Calls aggregate_ballot_results() to group by constituency
   - Generates constituency PDFs (one per unique province+constituency)
   - Generates batch summary PDF
   - Returns paths to generated PDF files

```python
def generate_pdfs(ballot_results: list[BallotData]) -> tuple[str, str]:
    \"\"\"Generate constituency and batch PDFs from results.\"\"\"
    if not ballot_results:
        return None, None

    # Create temp directory for PDFs
    pdf_dir = tempfile.mkdtemp(prefix="ballot_pdfs_")

    # Aggregate results
    aggregated = aggregate_ballot_results(ballot_results)

    # Generate batch summary PDF
    batch_pdf_path = os.path.join(pdf_dir, "batch_summary.pdf")
    generate_batch_pdf(aggregated, ballot_results, batch_pdf_path)

    # Generate first constituency PDF (for demo - user can generate others later)
    first_constituency_pdf = None
    for key, agg in aggregated.items():
        cons_pdf_path = os.path.join(pdf_dir, f"constituency_{key}.pdf")
        if generate_constituency_pdf(agg, cons_pdf_path):
            first_constituency_pdf = cons_pdf_path
            break  # Just use first one for now

    return batch_pdf_path, first_constituency_pdf
```

3. **Update interface with download buttons**:
```python
with gr.Row():
    batch_pdf_btn = gr.Button("Download Batch Summary PDF")
    constituency_pdf_btn = gr.Button("Download Constituency Report PDF")

batch_pdf_output = gr.File(label="Batch Summary PDF", visible=False)
constituency_pdf_output = gr.File(label="Constituency Report PDF", visible=False)
```

4. **Wire up button clicks**:
   - Store ballot_results in a gr.State()
   - Download buttons read from State and generate PDFs
   - Return gr.File components with generated paths
</action>
  <verify>python -c "from web_ui import generate_pdfs; print('PDF generation OK')" && echo "PDF function works"</verify>
  <done>Download buttons generate constituency and batch PDFs and return them as downloadable files</done>
</task>

<task type="auto">
  <name>Task 3: Integrate full workflow with state management</name>
  <files>web_ui.py</files>
  <action>
Complete the web interface by integrating all components with proper state management.

1. **Update process_ballots function** to:
   - Return ballot_results in addition to display data
   - Store results in a list that can be accessed by PDF buttons
   - Handle the three-output case: (results_table, error_text, ballot_results)

2. **Add gr.State for ballot results**:
```python
ballot_state = gr.State(value=None)  # Stores list[BallotData]

# On process click, update state
process_btn.click(
    fn=process_ballots,
    inputs=[file_input],
    outputs=[results_table, error_output, ballot_state]
)
```

3. **Create download handler functions**:
```python
def download_batch_pdf(ballot_results):
    if not ballot_results:
        return None
    batch_path, _ = generate_pdfs(ballot_results)
    return batch_path

def download_constituency_pdf(ballot_results):
    if not ballot_results:
        return None
    _, constituency_path = generate_pdfs(ballot_results)
    return constituency_path
```

4. **Wire download buttons**:
```python
batch_pdf_btn.click(
    fn=download_batch_pdf,
    inputs=[ballot_state],
    outputs=[batch_pdf_output]
)

constituency_pdf_btn.click(
    fn=download_constituency_pdf,
    inputs=[ballot_state],
    outputs=[constituency_pdf_output]
)
```

5. **Add file cleanup on new upload**:
   - Clear previous PDF outputs when new files uploaded
   - Clear state when new batch starts

6. **Add user feedback**:
   - Show "Processing..." status during batch
   - Show "Ready for download" after PDFs generated
   - Disable download buttons until processing complete

7. **Add final UI polish**:
   - Add gr.Examples with sample images if available in repo
   - Add footer with version info
   - Add clear button to reset the interface

Keep the interface simple - no authentication, no user accounts, single-user focus.
</action>
  <verify>python -c "from web_ui import demo, download_batch_pdf, download_constituency_pdf; print('Full workflow OK')" && echo "All functions work"</verify>
  <done>Full workflow: upload -> process -> view table -> download PDFs works end-to-end</done>
</task>

</tasks>

<verification>
1. Results table shows Image, Province, Constituency, Station, Form Type, Confidence, Votes columns
2. Vote counts display correctly (candidate names and vote numbers)
3. "Download Batch Summary PDF" button generates and returns PDF file
4. "Download Constituency Report PDF" button generates and returns PDF file
5. PDFs open correctly and contain expected content
6. State management works (ballot_results persist between process and download)
</verification>

<success_criteria>
1. User can view extracted vote counts in a structured table with columns for all key data
2. User can download constituency PDF reports directly from web UI
3. User can download batch summary PDF directly from web UI
4. Full workflow from upload to download works without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-web-interface/06-02-SUMMARY.md`
</output>
