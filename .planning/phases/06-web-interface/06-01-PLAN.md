---
phase: 06-web-interface
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - web_ui.py
autonomous: true
user_setup: []
must_haves:
  truths:
    - "User can upload 100-500 ballot images via web browser"
    - "User sees a live progress bar during batch processing"
    - "User sees clear error messages when ballots fail OCR"
    - "Thai text displays correctly throughout the interface"
  artifacts:
    - path: "web_ui.py"
      provides: "Gradio web interface with upload and progress"
      min_lines: 80
      exports: ["demo", "GradioProgressCallback"]
  key_links:
    - from: "web_ui.py"
      to: "batch_processor.py"
      via: "from batch_processor import BatchProcessor, ProgressCallback"
      pattern: "BatchProcessor\\("
    - from: "GradioProgressCallback"
      to: "ProgressCallback"
      via: "implements on_start, on_progress, on_error, on_complete"
      pattern: "def on_progress"
---

<objective>
Create Gradio web interface with multi-file upload (100-500 images) and real-time progress bar using the ProgressCallback protocol from Phase 5.

Purpose: Enable non-technical users to upload ballot images and see live OCR progress through a web browser.
Output: web_ui.py with Gradio interface, GradioProgressCallback class
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@batch_processor.py

## Key Integration Points

1. **BatchProcessor with ProgressCallback** (from Phase 5):
```python
from batch_processor import BatchProcessor, ProgressCallback

processor = BatchProcessor(max_workers=5, rate_limit=2.0)
result = processor.process_batch(image_paths, progress_callback=my_callback)
```

2. **ProgressCallback Protocol** (already exists):
```python
class ProgressCallback(Protocol):
    def on_start(self, total: int) -> None: ...
    def on_progress(self, current: int, total: int, path: str, result: Optional[BallotData]) -> None: ...
    def on_error(self, current: int, total: int, path: str, error: str) -> None: ...
    def on_complete(self, results: list, errors: list) -> None: ...
```

3. **Gradio Progress Pattern** (from research):
```python
import gradio as gr

def process_uploads(files, progress=gr.Progress()):
    progress(0, desc="Starting...")
    for i, file in enumerate(files):
        progress((i + 1) / len(files), desc=f"Processing {i+1}/{len(files)}")
        # process file
    return results
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GradioProgressCallback class</name>
  <files>web_ui.py</files>
  <action>
Create a new file `web_ui.py` with a `GradioProgressCallback` class that implements the ProgressCallback protocol from batch_processor.py.

The class must:
1. Accept a `gr.Progress()` object in its constructor
2. Implement all four ProgressCallback methods: `on_start`, `on_progress`, `on_error`, `on_complete`
3. Update the Gradio progress bar with `progress(current/total, desc=...)` format
4. Track errors internally for display after processing completes
5. Handle the case where progress is None (defensive programming)

Implementation pattern:
```python
import gradio as gr
from typing import Optional
from batch_processor import BallotData

class GradioProgressCallback:
    def __init__(self, progress: Optional[gr.Progress] = None):
        self.progress = progress
        self._errors: list[dict] = []

    def on_start(self, total: int) -> None:
        if self.progress:
            self.progress(0, desc=f"Starting batch of {total} images...")

    def on_progress(self, current: int, total: int, path: str, result: Optional[BallotData]) -> None:
        if self.progress:
            filename = path.split("/")[-1] if "/" in path else path
            self.progress(current / total, desc=f"[{current}/{total}] {filename}")

    def on_error(self, current: int, total: int, path: str, error: str) -> None:
        self._errors.append({"path": path, "error": error})
        if self.progress:
            self.progress(current / total, desc=f"[{current}/{total}] Error on {path}")

    def on_complete(self, results: list, errors: list) -> None:
        if self.progress:
            self.progress(1.0, desc=f"Complete: {len(results)} succeeded, {len(errors)} failed")
```

Do NOT use ABC inheritance - use duck typing with the protocol.
</action>
  <verify>python -c "from web_ui import GradioProgressCallback; c = GradioProgressCallback(); print('OK')" && echo "Callback class works"</verify>
  <done>GradioProgressCallback class implements all four ProgressCallback methods and can be instantiated without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Gradio interface with file upload and batch processing</name>
  <files>web_ui.py</files>
  <action>
Add the Gradio interface to `web_ui.py` with the following components:

1. **process_ballots function** that:
   - Accepts a list of files from `gr.File(file_count="multiple")`
   - Saves uploaded files to a temp directory
   - Creates a BatchProcessor with max_workers=5, rate_limit=2.0
   - Uses GradioProgressCallback for progress updates
   - Returns a tuple: (results_dataframe, error_messages)

2. **format_results function** that:
   - Takes the BatchResult from BatchProcessor
   - Returns a list of lists for gr.Dataframe display
   - Columns: Image, Province, Constituency, Station, Form Type, Confidence

3. **Gradio Blocks interface** with:
   - Title: "Thai Election Ballot OCR"
   - Description: "Upload ballot images to extract vote counts"
   - gr.File with file_count="multiple", label="Upload Ballot Images (100-500)"
   - gr.Button("Process Ballots")
   - gr.Dataframe for results display with headers
   - gr.Textbox for error messages (errors only, not all results)

4. **Launch configuration**:
   - `demo.launch(server_name="0.0.0.0", server_port=7860)` for external access
   - Add `if __name__ == "__main__":` guard

Use gr.Blocks() pattern for flexibility:
```python
with gr.Blocks(title="Thai Election Ballot OCR") as demo:
    gr.Markdown("# Thai Election Ballot OCR")
    gr.Markdown("Upload ballot images to extract vote counts")

    with gr.Row():
        file_input = gr.File(file_count="multiple", label="Upload Ballot Images")

    with gr.Row():
        process_btn = gr.Button("Process Ballots", variant="primary")

    with gr.Row():
        results_table = gr.Dataframe(
            headers=["Image", "Province", "Constituency", "Station", "Form Type", "Confidence"],
            label="Extracted Results"
        )

    with gr.Row():
        error_output = gr.Textbox(label="Errors", lines=5)

    process_btn.click(
        fn=process_ballots,
        inputs=[file_input],
        outputs=[results_table, error_output]
    )
```

Import tempfile for temp directory handling. Handle the case where files is None or empty.
</action>
  <verify>python -c "from web_ui import demo; print('Gradio interface OK')" && echo "Interface loads"</verify>
  <done>Gradio interface launches and displays file upload component with Process button</done>
</task>

<task type="auto">
  <name>Task 3: Add Thai text support and error handling</name>
  <files>web_ui.py</files>
  <action>
Enhance the web_ui.py with:

1. **Thai text display support**:
   - Gradio handles UTF-8 by default, but ensure error messages preserve Thai text
   - Use descriptive Thai error messages where appropriate (e.g., province names)
   - Test with Thai filenames in file list

2. **Comprehensive error handling** in process_ballots:
   - Handle empty file list: return "Please upload at least one image"
   - Handle file read errors: catch and report per-file errors
   - Handle API errors: already handled by BatchProcessor, but surface clearly
   - Catch any unexpected exceptions and return user-friendly message

3. **Results formatting improvements**:
   - Show confidence as "High/Medium/Low" text, not raw float
   - Handle None values gracefully (show "-" for missing data)
   - Sort results by filename for predictable display
   - Limit display to first 100 results with "(showing 100 of N)" message

4. **Error display improvements**:
   - Format errors as numbered list
   - Include filename (basename only), not full path
   - Truncate long error messages to 200 chars

Add logging import and basic logging for debugging:
```python
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
```

Do NOT add authentication - single-user for v1.1.
</action>
  <verify>python -c "from web_ui import process_ballots, format_results; print('Functions OK')" && echo "Error handling works"</verify>
  <done>Error handling covers empty uploads, file errors, API errors. Thai text displays correctly.</done>
</task>

</tasks>

<verification>
1. `python -c "from web_ui import demo, GradioProgressCallback"` runs without error
2. GradioProgressCallback has on_start, on_progress, on_error, on_complete methods
3. Gradio interface has file_count="multiple" for batch upload
4. Progress bar integration works via gr.Progress()
5. Thai text displays correctly (test with Thai strings)
</verification>

<success_criteria>
1. User can upload 100-500 ballot images via web browser (file_count="multiple")
2. User sees a live progress bar during batch processing (GradioProgressCallback)
3. User sees clear error messages when ballots fail OCR
4. Thai text displays correctly throughout the interface
</success_criteria>

<output>
After completion, create `.planning/phases/06-web-interface/06-01-SUMMARY.md`
</output>
