---
phase: 05-parallel-processing
plan: "02"
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - batch_processor.py
autonomous: true
must_haves:
  truths:
    - "User sees real-time progress updates during batch processing (X of Y ballots processed)"
    - "System cleans up memory during large batches to prevent out-of-memory errors"
    - "Progress callback interface allows external systems to receive updates"
  artifacts:
    - path: "batch_processor.py"
      provides: "Progress callback interface and memory cleanup"
      contains: "ProgressCallback"
      exports: ["ProgressCallback", "BatchProcessor.process_batch"]
  key_links:
    - from: "BatchProcessor.process_batch"
      to: "ProgressCallback"
      via: "callback.on_progress(current, total, path)"
      pattern: "callback\\.on_progress"
    - from: "process_batch"
      to: "gc.collect()"
      via: "memory cleanup every 50 ballots"
      pattern: "gc\\.collect"
---

<objective>
Add progress callback interface for real-time updates and memory cleanup for large batches (100-500 ballots). This enables UI integration and prevents OOM errors during extended processing.

Purpose: Users can monitor batch progress and the system remains stable during large batch processing.
Output: Enhanced BatchProcessor with ProgressCallback interface and memory management
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md

# Previous plan
@.planning/phases/05-parallel-processing/05-01-PLAN.md (after completion, use SUMMARY)

# Key context from research:
# - Progress callback interface for UI integration (Phase 6 web interface will use this)
# - Memory cleanup every 50 ballots prevents OOM
# - reportlab builds PDFs in memory - may need gc.collect() after constituency chunks
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProgressCallback protocol/interface</name>
  <files>batch_processor.py</files>
  <action>
Add `ProgressCallback` protocol class to batch_processor.py for progress tracking.

Implementation:
1. Import `typing.Protocol` and `@runtime_checkable`
2. Create `ProgressCallback` protocol with methods:
   - `on_start(total: int) -> None` - called when batch starts
   - `on_progress(current: int, total: int, path: str, result: Optional[BallotData]) -> None` - called after each ballot
   - `on_error(current: int, total: int, path: str, error: str) -> None` - called on error
   - `on_complete(results: list, errors: list) -> None` - called when batch completes

3. Create a `ConsoleProgressCallback` implementation:
   - Prints progress to stdout like "[3/100] Processing: ballot_003.png"
   - Shows summary on completion
   - Uses `\r` for in-place updates when in terminal

4. Create a `NullProgressCallback` implementation:
   - No-op implementation for when progress is not needed
   - Useful for testing and non-interactive use

Using Protocol allows any class with these methods to be used, enabling future Gradio integration.
  </action>
  <verify>
    ```bash
    python -c "
from batch_processor import ProgressCallback, ConsoleProgressCallback, NullProgressCallback
from typing import runtime_checkable

# Verify Protocol
assert runtime_checkable(ProgressCallback), 'ProgressCallback should be runtime_checkable'

# Verify implementations
console = ConsoleProgressCallback()
null = NullProgressCallback()

# Test method existence
console.on_start(10)
console.on_progress(1, 10, 'test.png', None)
console.on_error(2, 10, 'error.png', 'test error')
console.on_complete([], [])

null.on_start(10)
null.on_progress(1, 10, 'test.png', None)

print('ProgressCallback protocol verified')
"
    ```
  </verify>
  <done>ProgressCallback protocol with ConsoleProgressCallback and NullProgressCallback implementations</done>
</task>

<task type="auto">
  <name>Task 2: Integrate progress callback into BatchProcessor.process_batch</name>
  <files>batch_processor.py</files>
  <action>
Modify `BatchProcessor.process_batch` to accept and use progress callbacks.

Changes to `process_batch` method signature:
```python
def process_batch(
    self,
    image_paths: list[str],
    progress_callback: Optional[ProgressCallback] = None
) -> tuple[list[BallotData], list[dict]]:
```

Implementation:
1. Accept optional `progress_callback` parameter
2. If callback is None, use `NullProgressCallback()`
3. Call `callback.on_start(len(image_paths))` at start
4. Inside the result collection loop:
   - Track current count (1-indexed for user display)
   - Call `callback.on_progress(current, total, path, result)` for each success
   - Call `callback.on_error(current, total, path, error_str)` for each error
5. Call `callback.on_complete(results, errors)` at end

Update `process_single` to return more error info for callback:
- Catch exceptions and include full error message in error dict
</action>
  <verify>
    ```bash
    python -c "
from batch_processor import BatchProcessor, ConsoleProgressCallback
import inspect

# Verify updated signature
bp = BatchProcessor()
sig = inspect.signature(bp.process_batch)
params = list(sig.parameters.keys())
assert 'progress_callback' in params, 'Missing progress_callback parameter'

# Check default is None
default = sig.parameters['progress_callback'].default
assert default is None, f'progress_callback default should be None, got {default}'

print('process_batch signature updated correctly')
"
    ```
  </verify>
  <done>BatchProcessor.process_batch accepts and calls progress callbacks at start, progress, error, and completion</done>
</task>

<task type="auto">
  <name>Task 3: Add memory cleanup for large batches</name>
  <files>batch_processor.py</files>
  <action>
Add memory cleanup to `BatchProcessor.process_batch` to prevent OOM during large batches.

Implementation:
1. Import `gc` (garbage collector)
2. Define constant `MEMORY_CLEANUP_INTERVAL = 50` (cleanup every 50 ballots)
3. Inside the result collection loop:
   - After every `MEMORY_CLEANUP_INTERVAL` results, call `gc.collect()`
   - Log cleanup message if verbose/debug mode

4. Add optional `enable_memory_cleanup` parameter to constructor:
   - Default `True`
   - Allows disabling for testing/debugging

5. Consider adding cleanup after rate limiter wait:
   - If rate limiter had to wait (> 0.1s), memory cleanup is more beneficial
   - This is opportunistic cleanup

Memory cleanup is critical because:
- Each ballot processes an image (~500KB-2MB in memory as base64)
- Large batches (500 ballots) could use 250MB-1GB just for images
- reportlab PDF generation also uses significant memory
- gc.collect() frees memory from completed ballots
  </action>
  <verify>
    ```bash
    python -c "
from batch_processor import BatchProcessor, MEMORY_CLEANUP_INTERVAL

# Verify constant exists
assert MEMORY_CLEANUP_INTERVAL == 50, f'Expected 50, got {MEMORY_CLEANUP_INTERVAL}'

# Verify parameter in constructor
bp = BatchProcessor(enable_memory_cleanup=True)
assert hasattr(bp, 'enable_memory_cleanup'), 'Missing enable_memory_cleanup attribute'
assert bp.enable_memory_cleanup == True

bp_no_cleanup = BatchProcessor(enable_memory_cleanup=False)
assert bp_no_cleanup.enable_memory_cleanup == False

print('Memory cleanup configuration verified')
"
    ```
  </verify>
  <done>Memory cleanup runs every 50 ballots during batch processing, configurable via enable_memory_cleanup</done>
</task>

<task type="auto">
  <name>Task 4: Add verbose logging and statistics to BatchResult</name>
  <files>batch_processor.py</files>
  <action>
Enhance `BatchResult` dataclass with timing and statistics, add verbose logging option.

Changes to `BatchResult` dataclass (add fields):
```python
@dataclass
class BatchResult:
    results: list[BallotData]
    errors: list[dict]
    total: int
    processed: int
    # NEW fields:
    start_time: float  # Unix timestamp
    end_time: float  # Unix timestamp
    duration_seconds: float
    requests_per_second: float  # Actual achieved rate
    memory_cleanups: int  # Number of gc.collect() calls
    retries: int  # Total retry attempts across all ballots
```

Changes to `BatchProcessor`:
1. Add `verbose: bool = False` to constructor
2. Track start/end time using `time.time()`
3. Track retry count (from tenacity retry statistics)
4. Track memory cleanup count
5. Calculate actual requests/second at end

Changes to `ConsoleProgressCallback`:
1. Add `verbose: bool = False` to constructor
2. When verbose, print additional details:
   - Retry attempts
   - Memory cleanups
   - Rate limiter waits
</action>
  <verify>
    ```bash
    python -c "
from batch_processor import BatchResult, BatchProcessor, ConsoleProgressCallback
from dataclasses import fields

# Verify BatchResult has new fields
field_names = [f.name for f in fields(BatchResult)]
required_fields = ['start_time', 'end_time', 'duration_seconds', 'requests_per_second', 'memory_cleanups', 'retries']
for rf in required_fields:
    assert rf in field_names, f'BatchResult missing field: {rf}'

# Verify verbose option
bp = BatchProcessor(verbose=True)
assert hasattr(bp, 'verbose'), 'Missing verbose attribute'

cpc = ConsoleProgressCallback(verbose=True)
assert hasattr(cpc, 'verbose'), 'ConsoleProgressCallback missing verbose'

print('BatchResult and verbose logging verified')
"
    ```
  </verify>
  <done>BatchResult includes timing statistics, verbose mode provides detailed logging for debugging</done>
</task>

</tasks>

<verification>
1. ProgressCallback protocol works with isinstance() checks
2. ConsoleProgressCallback displays progress correctly
3. BatchProcessor calls progress callbacks at appropriate times
4. Memory cleanup runs every 50 ballots
5. BatchResult includes timing statistics
6. CLI can use --parallel with progress display
</verification>

<success_criteria>
- ProgressCallback protocol for UI integration
- ConsoleProgressCallback for terminal output
- Memory cleanup every 50 ballots prevents OOM
- BatchResult with timing and performance statistics
- Verbose logging mode for debugging
- Ready for Phase 6 web interface integration
</success_criteria>

<output>
After completion, create `.planning/phases/05-parallel-processing/05-02-SUMMARY.md`
</output>
